{"version":3,"file":"table-selection.min.js","mappings":"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","sources":["webpack://TableSelection/webpack/universalModuleDefinition","webpack://TableSelection/webpack/bootstrap","webpack://TableSelection/webpack/runtime/define property getters","webpack://TableSelection/webpack/runtime/hasOwnProperty shorthand","webpack://TableSelection/./src/ts/TableSelection.ts","webpack://TableSelection/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TableSelection\"] = factory();\n\telse\n\t\troot[\"TableSelection\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/*!\n * TableSelection library v1.0.0 (https://github.com/PXLWidgets/table-selection)\n * Copyright (c) 2019 Wouter Smit\n * Licensed under MIT (https://github.com/PXLWidgets/table-selection/blob/master/LICENSE)\n */\n\nimport { TableSelectionConfig } from \"./interfaces/TableSelectionConfig\";\nimport { TableSelectionRange } from \"./interfaces/TableSelectionRange\";\nimport { TableSelectionTableElements } from \"./interfaces/TableSelectionTableElements\";\n\nconst defaultConfig: TableSelectionConfig = {\n  copyOnSelection: false,\n  rootDocument: document,\n  selector: \".table-selection\",\n  selectionCssMode: \"style\",\n  selectionCssClass: \"selected\",\n};\n\nexport class TableSelection {\n  config: TableSelectionConfig;\n  range: TableSelectionRange | null = null;\n  elements: TableSelectionTableElements;\n\n  constructor(config: TableSelectionConfig = defaultConfig) {\n    this.config = { ...config };\n\n    const { rootDocument } = this.config;\n\n    // Hide default selection\n    const styles = rootDocument.createElement(\"style\");\n    styles.innerHTML = `${this.config.selector} *::selection {\n            background: transparent;\n            color: inherit;\n        }`;\n    rootDocument.head.appendChild(styles);\n\n    rootDocument.addEventListener(\"selectionchange\", () =>\n      this.onSelectionChange()\n    );\n    rootDocument.addEventListener(\"copy\", (e) => this.handleCopy(e));\n  }\n\n  protected async onSelectionChange(): Promise<void> {\n    const selection = this.config.rootDocument.getSelection();\n\n    this.deselect();\n    if (!selection || selection.isCollapsed) {\n      return;\n    }\n\n    const startCell: HTMLTableCellElement | null = this.getCellElementFromNode(\n      selection.anchorNode\n    );\n    const endCell: HTMLTableCellElement | null = this.getCellElementFromNode(\n      selection.focusNode\n    );\n\n    if (!startCell || !endCell) {\n      return;\n    }\n\n    const startTableElements = this.getTableElementsFromCellElement(startCell);\n    const endTableElements = this.getTableElementsFromCellElement(endCell);\n    if (!startTableElements || !endTableElements) {\n      return;\n    }\n\n    const isSameTable = startTableElements.table === endTableElements.table;\n    if (!isSameTable) {\n      return;\n    }\n\n    this.elements = startTableElements;\n\n    this.getRangeByStartAndEndElement(startCell, endCell);\n    this.getRowElements();\n    this.getRowsAndCells();\n\n    if (this.range) {\n      if (this.config.copyOnSelection) {\n        const selectionText = this.getSelectionText(this.range);\n        await this.copyToClipboard(selectionText);\n      }\n\n      this.select();\n    } else {\n      this.deselect();\n    }\n  }\n\n  protected getRangeByStartAndEndElement(\n    startCellElement: HTMLTableCellElement,\n    endCellElement: HTMLTableCellElement\n  ): void {\n    const startRowElement: HTMLTableRowElement | null =\n      startCellElement.parentElement as HTMLTableRowElement;\n    const endRowElement: HTMLTableRowElement | null =\n      endCellElement.parentElement as HTMLTableRowElement;\n\n    if (!startRowElement || !endRowElement) {\n      return;\n    }\n\n    this.range = {\n      start: {\n        row: startRowElement.rowIndex + 1,\n        cell: startCellElement.cellIndex + 1,\n      },\n      end: {\n        row: endRowElement.rowIndex + 1,\n        cell: endCellElement.cellIndex + 1,\n      },\n      rowElements: [],\n      rows: [],\n      cells: [],\n    };\n\n    // Flip start/end if end > start\n    if (this.range.start.cell > this.range.end.cell) {\n      [this.range.start.cell, this.range.end.cell] = [\n        this.range.end.cell,\n        this.range.start.cell,\n      ];\n    }\n    if (this.range.start.row > this.range.end.row) {\n      [this.range.start.row, this.range.end.row] = [\n        this.range.end.row,\n        this.range.start.row,\n      ];\n    }\n  }\n\n  protected getRowElements(): void {\n    if (!this.range || !this.elements.table) {\n      return;\n    }\n\n    const numTableHeaders =\n      this.elements.table.querySelectorAll(\"thead tr\").length;\n    let theadRows: HTMLTableRowElement[] = [];\n    let tbodyRows: HTMLTableRowElement[] = [];\n\n    const theadStart =\n      this.range.start.row <= numTableHeaders\n        ? Math.min(numTableHeaders, this.range.start.row)\n        : null;\n    const theadEnd =\n      this.range.start.row <= numTableHeaders\n        ? Math.min(numTableHeaders, this.range.end.row)\n        : null;\n\n    const tbodyStart =\n      this.range.end.row > numTableHeaders\n        ? Math.max(1, this.range.start.row - numTableHeaders)\n        : null;\n    const tbodyEnd =\n      this.range.end.row > numTableHeaders\n        ? Math.max(1, this.range.end.row - numTableHeaders)\n        : null;\n\n    if (theadStart) {\n      theadRows = Array.from(\n        this.elements.table.querySelectorAll(\n          `thead tr:nth-of-type(n+${theadStart}):nth-of-type(-n+${theadEnd})`\n        )\n      );\n    }\n\n    if (tbodyStart) {\n      tbodyRows = Array.from(\n        this.elements.table.querySelectorAll(\n          `tbody tr:nth-of-type(n+${tbodyStart}):nth-of-type(-n+${tbodyEnd})`\n        )\n      );\n    }\n\n    this.range.rowElements = [...theadRows, ...tbodyRows];\n  }\n\n  protected getRowsAndCells(): void {\n    if (!this.range || !this.range.rowElements) {\n      return;\n    }\n\n    let cells: HTMLTableCellElement[] = [];\n    this.range.rowElements.forEach((row: HTMLTableRowElement, i: number) => {\n      if (!this.range) {\n        return;\n      }\n\n      const cellsInRow = Array.from(\n        row.querySelectorAll(\n          [\n            `td:nth-of-type(n+${this.range.start.cell}):nth-of-type(-n+${this.range.end.cell})`,\n            `th:nth-of-type(n+${this.range.start.cell}):nth-of-type(-n+${this.range.end.cell})`,\n          ].join(\",\")\n        )\n      ) as HTMLTableCellElement[];\n\n      cells = [...cells, ...cellsInRow];\n      this.range.rows[i] = cellsInRow;\n    });\n\n    this.range.cells = cells;\n  }\n\n  protected getCellElementFromNode(\n    inputNode: Node | null\n  ): HTMLTableCellElement | null {\n    if (!inputNode) {\n      return null;\n    }\n\n    const element: HTMLTableCellElement | null =\n      inputNode.nodeName === \"#text\"\n        ? (inputNode.parentElement as HTMLTableCellElement).closest(\"td,th\")\n        : (inputNode as HTMLTableCellElement);\n\n    if (!element || ![\"TD\", \"TH\"].includes(element.tagName)) {\n      return null;\n    }\n\n    return element;\n  }\n\n  protected getTableElementsFromCellElement(\n    cellElement: HTMLTableCellElement\n  ): TableSelectionTableElements | null {\n    if (\n      !cellElement ||\n      !cellElement.parentElement ||\n      !cellElement.parentElement.parentElement\n    ) {\n      return null;\n    }\n\n    const tHeadOrBody = cellElement.parentElement.parentElement;\n    const table: HTMLTableElement = [\"TBODY\", \"THEAD\"].includes(\n      tHeadOrBody.tagName\n    )\n      ? (tHeadOrBody.parentElement as HTMLTableElement)\n      : (tHeadOrBody as HTMLTableElement);\n\n    if (\n      !table ||\n      !this.config.selector ||\n      !table.matches(this.config.selector)\n    ) {\n      return null;\n    }\n\n    return {\n      table,\n      thead: table.querySelector(\"thead\") as HTMLTableSectionElement,\n      tbody: table.querySelector(\"tbody\") as HTMLTableSectionElement,\n    };\n  }\n\n  protected select(): void {\n    if (this.range && this.range.cells) {\n      this.range.cells.forEach((cellElement) => {\n        if (\n          this.config.selectionCssMode === \"cssClass\" &&\n          this.config.selectionCssClass\n        ) {\n          cellElement.classList.add(this.config.selectionCssClass);\n        } else {\n          cellElement.style.backgroundColor =\n            \"var(--table-selection-background-color, Highlight)\";\n          cellElement.style.color =\n            \"var(--table-selection-color, HighlightText)\";\n        }\n      });\n    }\n  }\n\n  protected deselect(): void {\n    if (this.range && this.range.cells) {\n      this.range.cells.forEach((cellElement) => {\n        if (\n          this.config.selectionCssMode === \"cssClass\" &&\n          this.config.selectionCssClass\n        ) {\n          cellElement.classList.remove(this.config.selectionCssClass);\n        } else {\n          cellElement.style.removeProperty(\"background-color\");\n          cellElement.style.removeProperty(\"color\");\n        }\n      });\n      this.range = null;\n    }\n  }\n\n  protected handleCopy(e: ClipboardEvent): void {\n    if (!this.range || !this.range.rows || !e.clipboardData) {\n      return;\n    }\n\n    const selectionText = this.getSelectionText(this.range);\n\n    if (!selectionText) {\n      return;\n    }\n\n    e.clipboardData.setData(\"text/plain\", selectionText);\n    e.preventDefault();\n  }\n\n  protected getSelectionText(range: TableSelectionRange): string {\n    // get number of rows and cells in range\n    const n_rows = range.rows.length;\n    const n_cells = range.rows[0].length;\n\n    // store array of innerText of each cell in range\n    const cellTexts: string[][] = [];\n    for (let i = 0; i < n_rows; i++) {\n      cellTexts.push([]);\n      for (let j = 0; j < n_cells; j++) {\n        cellTexts[i].push(range.rows[i][j].innerText.trim());\n      }\n    }\n\n    // merge columns that can be merged\n    const mergedCellTexts = this.mergeCellTexts(cellTexts);\n\n    // manipulate merged cell texts\n    const manipulatedMergedCellTexts = this.manipulateMergedCellTexts(mergedCellTexts);\n\n    // for each thing in cellTexts, mergedCellTexts, and manipulatedMergedCellTexts, log it with the name\n    console.log(\"cellTexts\");\n    console.log(cellTexts);\n\n    console.log(\"mergedCellTexts\");\n    console.log(mergedCellTexts);\n\n    console.log(\"manipulatedMergedCellTexts\");\n    console.log(manipulatedMergedCellTexts);\n\n    // join cellTexts\n    const cellTextsJoined = manipulatedMergedCellTexts.map((row) => row.join(\"\\t\")).join(\"\\r\\n\");\n\n    return cellTextsJoined;\n  }\n\n  protected manipulateMergedCellTexts(mergedCellTexts: string[][]): string[][] {\n    /* manipulate merged cell texts */\n\n    // manipulate each cell text\n    for (let i = 0; i < mergedCellTexts.length; i++) {\n      for (let j = 0; j < mergedCellTexts[i].length; j++) {\n        mergedCellTexts[i][j] = this.manipulateString(mergedCellTexts[i][j]);\n      }\n    }\n\n    return mergedCellTexts;\n  }\n\n  protected manipulateString(input: string): string {\n    // Replace any type of dash with a '0'\n    input = input.replace(/[-–—]/g, \"0\");\n\n    // Replace the opening parenthesis with a negative sign if there's no closing parenthesis\n    const hasOpeningWithoutClosing =\n      input.includes(\"(\") && !input.includes(\")\");\n    if (hasOpeningWithoutClosing) {\n      input = input.replace(\"(\", \"-\");\n    }\n\n    return input;\n  }\n\n  protected canMergeCells(\n    str1: string,\n    str2: string,\n    allowedUnits: string[] = [\"$\", \"%\", \"bps\", \"pts\"]\n  ): boolean {\n    // Check if one of the string is empty\n    if (str1 === \"\" || str2 === \"\") return true;\n\n    // Check if exactly one of them contains an allowed unit\n    const containsAllowedUnit = (str: string) =>\n      allowedUnits.some((unit) => str.includes(unit));\n\n    const isNumericOrSpecial = (str: string) => \n      /^[0-9.,()-]+$/.test(str);\n\n    if (containsAllowedUnit(str1) && isNumericOrSpecial(str2)) return true;\n    if (containsAllowedUnit(str2) && isNumericOrSpecial(str1)) return true;\n\n    // Check if upon merging, they form a valid parenthetical number\n    const mergedString = str1 + str2;\n    const validParentheticalNumberRegex = /^\\(\\$?\\d{1,3}(,\\d{3})*(\\.\\d+)?\\)%?$/;\n    return validParentheticalNumberRegex.test(mergedString);\n  }\n\n  protected canMergeColumns(colA: string[], colB: string[]): boolean {\n    /* check if two columns can be merged */\n\n    // if the columns have different lengths, they cannot be merged\n    if (colA.length !== colB.length) {\n      return false;\n    }\n\n    // check if the columns can be merged\n    for (let i = 0; i < colA.length; i++) {\n      if (!this.canMergeCells(colA[i], colB[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  protected mergeColumns(colA: string[], colB: string[]): string[] {\n    /* merge two columns */\n    const mergedCol: string[] = [];\n\n    for (let i = 0; i < colA.length; i++) {\n      mergedCol.push(colA[i] + colB[i]);\n    }\n\n    return mergedCol;\n  }\n\n  protected mergeCellTexts(cellTexts: string[][]): string[][] {\n    /* merge columns that can be merged */\n\n    // ensure that cellTexts is rectangular\n    const n_rows = cellTexts.length;\n    const n_cells = cellTexts[0].length;\n    if (!cellTexts.every((row) => row.length === n_cells)) {\n      throw new Error(\"cellTexts is not rectangular\");\n    }\n\n    // maintain an output array of merged cellTexts starting with the first column\n    const mergedCellTexts: string[][] = [cellTexts.map((row) => row[0])];\n\n    // iterate over the columns. If a column can be merged with the previous one, merge them\n    // otherwise, add the column to the output array\n    for (let i = 1; i < n_cells; i++) {\n      // get the last column in the output array\n      const prevCol = mergedCellTexts[mergedCellTexts.length - 1];\n      // get the current column\n      const curCol = cellTexts.map((row) => row[i]);\n\n      if (this.canMergeColumns(prevCol, curCol)) {\n        mergedCellTexts[mergedCellTexts.length - 1] = this.mergeColumns(\n          prevCol,\n          curCol\n        );\n      } else {\n        mergedCellTexts.push(curCol);\n      }\n    }\n\n    // transpose the output array to get the final merged cellTexts\n    const mergedCellTextsTransposed: string[][] = [];\n    for (let i = 0; i < mergedCellTexts[0].length; i++) {\n      mergedCellTextsTransposed.push(mergedCellTexts.map((row) => row[i]));\n    }\n\n    return mergedCellTextsTransposed;\n  }\n\n  protected async copyToClipboard(text: string): Promise<void> {\n    // console.log(`copying to clipboard: ${text}`)\n    const window = this.config.rootDocument.defaultView;\n\n    if (window === null) {\n      console.warn(\n        \"TableSelection: Could not access window, aborting copy to clipboard!\"\n      );\n\n      return;\n    }\n\n    await window.navigator.clipboard.writeText(text);\n    // console.log(`copied to clipboard: ${text}`)\n\n    if (this.config.copyOnSelectionCallback !== undefined) {\n      // console.log(`calling copyOnSelectionCallback with text=${text}`)\n      this.config.copyOnSelectionCallback(text);\n    }\n  }\n}\n","/*!\n * TableSelection library v1.0.0 (https://github.com/PXLWidgets/table-selection)\n * Copyright (c) 2019 Wouter Smit\n * Licensed under MIT (https://github.com/PXLWidgets/table-selection/blob/master/LICENSE)\n*/\n\nimport { TableSelection } from './ts/TableSelection';\n\nexport default TableSelection;\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","defaultConfig","copyOnSelection","rootDocument","document","selector","selectionCssMode","selectionCssClass","config","range","this","styles","createElement","innerHTML","head","appendChild","addEventListener","onSelectionChange","e","handleCopy","selection","getSelection","deselect","isCollapsed","startCell","getCellElementFromNode","anchorNode","endCell","focusNode","startTableElements","getTableElementsFromCellElement","endTableElements","table","elements","getRangeByStartAndEndElement","getRowElements","getRowsAndCells","selectionText","getSelectionText","copyToClipboard","select","startCellElement","endCellElement","startRowElement","parentElement","endRowElement","start","row","rowIndex","cell","cellIndex","end","rowElements","rows","cells","numTableHeaders","querySelectorAll","length","theadRows","tbodyRows","theadStart","Math","min","theadEnd","tbodyStart","max","tbodyEnd","Array","from","forEach","i","cellsInRow","join","inputNode","element","nodeName","closest","includes","tagName","cellElement","tHeadOrBody","matches","thead","querySelector","tbody","classList","add","style","backgroundColor","color","remove","removeProperty","clipboardData","setData","preventDefault","n_rows","n_cells","cellTexts","push","j","innerText","trim","mergedCellTexts","mergeCellTexts","manipulatedMergedCellTexts","manipulateMergedCellTexts","console","log","map","manipulateString","input","replace","canMergeCells","str1","str2","allowedUnits","containsAllowedUnit","str","some","unit","isNumericOrSpecial","test","canMergeColumns","colA","colB","mergeColumns","mergedCol","every","Error","prevCol","curCol","mergedCellTextsTransposed","text","window","defaultView","warn","navigator","clipboard","writeText","undefined","copyOnSelectionCallback"],"sourceRoot":""}